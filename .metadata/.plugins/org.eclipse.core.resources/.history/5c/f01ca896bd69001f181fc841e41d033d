package com.motorPM.config;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import org.springframework.web.socket.handler.TextWebSocketHandler;
import org.springframework.web.util.UriComponents;
import org.springframework.web.util.UriComponentsBuilder;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.motorPM.config.interceptor.JWTInterceptor;
import com.motorPM.domain.DTO.RealtimeDTO;
import com.motorPM.persistence.MemberRepository;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableScheduling
@EnableWebSocket // Boot WebSocket 활성화
@RequiredArgsConstructor

public class WebSocketConfig extends TextWebSocketHandler implements WebSocketConfigurer {
	// 사용자 id와 웹소켓 세션을 매핑하는 맵
	private final ConcurrentHashMap<String, WebSocketSession> sessionMap = new ConcurrentHashMap<>();
	
	private final JWTInterceptor;
	
	private final MemberRepository mr;
    private List<Object[]> results;
    private int index;

	// WebSocket 연결명 설정 (http://localhost:8080/realtimews) ==> WebSocketConfigurer
	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(this, "realtimews")
		.setAllowedOrigins("*")
		.addInterceptors();
	}

	// Client가 접속 시 호출되는 메서드
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		sessionMap.put(session.getId(), session);
		System.out.println(session + " 클라이언트 접속");
	}

	// Client가 접속 해제 시 호출되는 메서드
	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
    	results = null;
    	index = 0;
    	sessionMap.remove(session.getId());
		System.out.println(session + " 클라이언트 접속 해제");
	}
	
	// Client에서 메시지가 왔을 때 호출되는 메서드 ==> 채팅과 같은 형태의 기능을 추가하지 않는다면 필요없는 메소드이다.
	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		results = mr.realDataResult(message.getPayload());
		index = 0;
	}

	// sendPushMessage를 0.781초 단위로 스케쥴링하여 호출하는 메서드
	@Scheduled(fixedRate = 781)
    public void getResults() {
    	if (results == null || results.isEmpty()) {
            return; // 결과가 없으면 작업 종료
        }
		if (index < results.size()) {
			Object[] result = results.get(index);
        		sendPushMessage(
        				RealtimeDTO.builder()
                		.asset_id(result[0].toString())
                		.created_at((Integer) result[1])
                		.spectrum_x((Float) result[2])
                		.spectrum_y((Float) result[3])
                		.spectrum_z((Float) result[4])
                		.build());
            index++;
        }
		else index = 0;
    }
	
	// FE에게 정보를 푸시하는 메소드
	public void sendPushMessage(RealtimeDTO data) {
		
		WebSocketSession session = sessionMap;
        // 해당 세션이 존재하고 열려있는 경우, 메시지를 전송
        if (session != null && session.isOpen()) {
        	
    		// 자바 객체를 JSON 문자열로 변환
    		ObjectMapper objectMapper = new ObjectMapper();
    		String msg;
    		try {
    			msg = objectMapper.writeValueAsString(data);
    		} catch (JsonProcessingException e) {
    			System.out.println("JSON Error:" + e.getMessage());
    			return;
    		}

    		// FE에 전송할 JSON 메시지객체 생성
    		TextMessage message = new TextMessage(msg);

    		// 블럭안에 코드를 수행하는 동안 map 객체에 대한 다른 스레드의 접근을 방지한다.
    		synchronized (sessionMap) {
    			for (WebSocketSession sess : sessionMap.values()) {
    				try {
    					sess.sendMessage(message);
    				} catch (IOException e) {
    					System.out.println(sess.getRemoteAddress() + ":" + e.getMessage());
    				}
    			}
    		}
        }
	}
}
